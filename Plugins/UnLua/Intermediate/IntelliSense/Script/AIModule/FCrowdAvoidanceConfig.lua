---Crowd manager is responsible for handling crowds using Detour (Recast library)
---Agents will respect navmesh for all steering and avoidance updates,
---but it's slower than AvoidanceManager solution (RVO, cares only about agents)
---All agents will operate on the same navmesh data, which will be picked from
---navigation system defaults (UNavigationSystemV1::SupportedAgents[0])
---To use it, you have to add CrowdFollowingComponent to your agent
---(usually: replace class of PathFollowingComponent in AIController by adding
--- those lines in controller's constructor
--- ACrowdAIController::ACrowdAIController(const FObjectInitializer& ObjectInitializer)
---     : Super(ObjectInitializer.SetDefaultSubobjectClass<UCrowdFollowingComponent>(TEXT("PathFollowingComponent")))
--- or simply add both components and switch move requests between them)
---Actors that should be avoided, but are not being simulated by crowd (like players)
---should implement CrowdAgentInterface AND register/unregister themselves with crowd manager:
--- UCrowdManager* CrowdManager = UCrowdManager::GetCurrent(this);
--- if (CrowdManager)
--- {
---    CrowdManager->RegisterAgent(this);
--- }
--- Check flags in CrowdDebugDrawing namespace (CrowdManager.cpp) for debugging options.
---@class FCrowdAvoidanceConfig
---@field public VelocityBias number
---@field public DesiredVelocityWeight number
---@field public CurrentVelocityWeight number
---@field public SideBiasWeight number
---@field public ImpactTimeWeight number
---@field public ImpactTimeRange number
---@field public CustomPatternIdx integer @index in SamplingPatterns array or 0xff for adaptive sampling
---@field public AdaptiveDivisions integer @adaptive sampling: number of divisions per ring
---@field public AdaptiveRings integer @adaptive sampling: number of rings
---@field public AdaptiveDepth integer @adaptive sampling: number of iterations at best velocity
local FCrowdAvoidanceConfig = {}
