---@class FRecastNavMeshGenerationProperties
---@field public TilePoolSize integer @maximum number of tiles NavMesh can hold
---@field public TileSizeUU number @size of single tile, expressed in uu
---@field public CellSize number @horizontal size of voxelization cell
---@field public CellHeight number @vertical size of voxelization cell
---@field public AgentRadius number @Radius of largest agent that can freely traverse the generated navmesh
---@field public AgentHeight number @Size of the tallest agent that will path with this navmesh.
---@field public AgentMaxSlope number @The maximum slope (angle) that the agent can move on.
---@field public AgentMaxStepHeight number @Largest vertical step the agent can perform
---@field public MinRegionArea number @The minimum dimension of area. Areas smaller than this will be discarded
---@field public MergeRegionSize number @The size limit of regions to be merged with bigger regions (watershed partitioning only)
---@field public MaxSimplificationError number @How much navigable shapes can get simplified - the higher the value the more freedom
---@field public TileNumberHardLimit integer @Absolute hard limit to number of navmesh tiles. Be very, very careful while modifying it while      having big maps with navmesh. A single, empty tile takes 176 bytes and empty tiles are      allocated up front (subject to change, but that's where it's at now)      @@note TileNumberHardLimit is always rounded up to the closest power of 2
---@field public RegionPartitioning integer @partitioning method for creating navmesh polys
---@field public LayerPartitioning integer @partitioning method for creating tile layers
---@field public RegionChunkSplits integer @number of chunk splits (along single axis) used for region's partitioning: ChunkyMonotone
---@field public LayerChunkSplits integer @number of chunk splits (along single axis) used for layer's partitioning: ChunkyMonotone
---@field public bSortNavigationAreasByCost boolean @Controls whether Navigation Areas will be sorted by cost before application     to navmesh during navmesh generation. This is relevant when there are     areas overlapping and we want to have area cost express area relevancy     as well. Setting it to true will result in having area sorted by cost,     but it will also increase navmesh generation cost a bit
---@field public bPerformVoxelFiltering boolean @controls whether voxel filtering will be applied (via FRecastTileGenerator::ApplyVoxelFilter).     Results in generated navmesh better fitting navigation bounds, but hits (a bit) generation performance
---@field public bMarkLowHeightAreas boolean @mark areas with insufficient free height above instead of cutting them out (accessible only for area modifiers using replace mode)
---@field public bUseExtraTopCellWhenMarkingAreas boolean @Expand the top of the area nav modifier's bounds by one cell height when applying to the navmesh.           If unset, navmesh on top of surfaces might not be marked by marking bounds flush with top surfaces (since navmesh is generated slightly above collision, depending on cell height).
---@field public bFilterLowSpanSequences boolean @if set, only single low height span will be allowed under valid one
---@field public bFilterLowSpanFromTileCache boolean @if set, only low height spans with corresponding area modifier will be stored in tile cache (reduces memory, can't modify without full tile rebuild)
---@field public bFixedTilePoolSize boolean @if true, the NavMesh will allocate fixed size pool for tiles, should be enabled to support streaming
local FRecastNavMeshGenerationProperties = {}
